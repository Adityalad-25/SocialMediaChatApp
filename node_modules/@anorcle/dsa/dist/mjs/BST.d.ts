import { compare } from './types/index.js';
declare class Node<T> {
    parent: Node<T> | null;
    left: Node<T> | null;
    right: Node<T> | null;
    data: T;
    height: number;
    constructor(data: T);
}
declare class BST<T> {
    protected $ROOT: Node<T> | null;
    protected compare: compare<T>;
    constructor(compare: compare<T>);
    get height(): number;
    private leftDescendant;
    private rightDescendant;
    /**
     * ## Get Right Ancestor of a Node
     * @param node The reference node
     * @returns The ancestor of a node with the next largest data | null if right ancestor doesn't exists
     */
    private rightAncestor;
    /**
     * ## Get Left Ancestor of a Node
     * @param node The reference node
     * @returns The ancestor of a node with the next largest data | null if right ancestor doesn't exists
     */
    private leftAncestor;
    protected adjustHeight(node: Node<T> | null): void;
    /**
     * ## Find Node with `data` in BST
     * It find the node with the given data and if node doesn't exists it return null
     * @param data target data to search
     * @param end Get first occurrence of node
     * @returns Node in BST | Null if node not found
     */
    findNode(data: T, end?: boolean, root?: Node<T> | null): Node<T> | null;
    /**
     * ## Find Insertion Point for new Node in BST
     * It find the node with the given data and if node doesn't exists it return the position
     * where the node can be inserted.
     * @param data target data to insert
     * @returns Node in BST | Null if tree is empty
     */
    protected insertionPoint(data: T, root?: Node<T> | null): Node<T> | null;
    /**
     * ## Get Next Node in BST
     * @param node The reference node
     * @returns Inorder Successor | null if current node is largest
     */
    next(node: Node<T>): Node<T> | null;
    /**
     * ## Get Previous Node in BST
     * @param node The reference node
     * @returns Inorder Predecessor | null if current node is smallest
     */
    prev(node: Node<T>): Node<T> | null;
    /**
     * ## Search List of Nodes
     * @param start staring value for search
     * @param end ending value for search
     * @returns A list of nodes within range [`start`, `end`]
     */
    rangeSearch(start: T, end: T): Node<T>[];
    insert(data: T): Node<T>;
    deleteElement(target: Node<T>): void;
    delete(data: T): void;
    private inorder;
    get toArray(): T[];
}
export default BST;
export type { Node };
