"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const InvalidOperationError_js_1 = __importDefault(require("./errors/InvalidOperationError.js"));
class PriorityQueue {
    constructor(compare, array = []) {
        this.compare = compare;
        this.$ARRAY = [];
        array.forEach(this.push.bind(this));
    }
    get size() {
        return this.$ARRAY.length;
    }
    parentIndex(index) {
        return Math.floor((index - 1) / 2);
    }
    leftChildIndex(index) {
        return 2 * index + 1;
    }
    rightChildIndex(index) {
        return 2 * index + 2;
    }
    swap(i, j) {
        const temp = this.$ARRAY[i];
        this.$ARRAY[i] = this.$ARRAY[j];
        this.$ARRAY[j] = temp;
    }
    shiftUp(node) {
        let parent = this.parentIndex(node);
        while (node > 0 && this.compare(this.$ARRAY[parent], this.$ARRAY[node]) == -1) {
            this.swap(parent, node);
            node = parent;
            parent = this.parentIndex(node);
        }
    }
    shiftDown(node) {
        let maxIndex = node;
        const left = this.leftChildIndex(node);
        const right = this.rightChildIndex(node);
        if (left < this.size && this.compare(this.$ARRAY[left], this.$ARRAY[maxIndex]) == 1) {
            maxIndex = left;
        }
        if (right < this.size && this.compare(this.$ARRAY[right], this.$ARRAY[maxIndex]) == 1) {
            maxIndex = right;
        }
        if (node !== maxIndex) {
            this.swap(node, maxIndex);
            this.shiftDown(maxIndex);
        }
    }
    push(value) {
        const index = this.size;
        this.$ARRAY.push(value);
        this.shiftUp(index);
    }
    pop() {
        if (this.size == 0) {
            throw new InvalidOperationError_js_1.default('PriorityQueue Error: Unable to pop from empty Queue');
        }
        const result = this.$ARRAY[0];
        this.$ARRAY[0] = this.$ARRAY[this.size - 1];
        this.$ARRAY.pop();
        this.shiftDown(0);
        return result;
    }
    top() {
        if (this.size == 0) {
            throw new InvalidOperationError_js_1.default('PriorityQueue Error: Unable to read from empty Queue');
        }
        return this.$ARRAY[0];
    }
    get front() {
        return this.top();
    }
    get toArray() {
        return this.$ARRAY.slice();
    }
}
exports.default = PriorityQueue;
