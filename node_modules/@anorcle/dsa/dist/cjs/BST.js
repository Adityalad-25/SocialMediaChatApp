"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Node {
    constructor(data) {
        this.data = data;
        this.parent = null;
        this.left = null;
        this.right = null;
        this.height = 1;
    }
}
class BST {
    constructor(compare) {
        this.$ROOT = null;
        this.compare = compare;
    }
    get height() {
        var _a;
        return ((_a = this.$ROOT) === null || _a === void 0 ? void 0 : _a.height) || 0;
    }
    leftDescendant(node) {
        if (node.left == null) {
            return node;
        }
        else {
            return this.leftDescendant(node.left);
        }
    }
    rightDescendant(node) {
        if (node.right == null) {
            return node;
        }
        else {
            return this.rightDescendant(node.right);
        }
    }
    /**
     * ## Get Right Ancestor of a Node
     * @param node The reference node
     * @returns The ancestor of a node with the next largest data | null if right ancestor doesn't exists
     */
    rightAncestor(node) {
        if (node.parent == null) {
            return null;
        }
        if (this.compare(node.data, node.parent.data) == -1) {
            return node.parent;
        }
        else {
            return this.rightAncestor(node.parent);
        }
    }
    /**
     * ## Get Left Ancestor of a Node
     * @param node The reference node
     * @returns The ancestor of a node with the next largest data | null if right ancestor doesn't exists
     */
    leftAncestor(node) {
        if (node.parent == null) {
            return null;
        }
        if (this.compare(node.data, node.parent.data) >= 0) {
            return node.parent;
        }
        else {
            return this.leftAncestor(node.parent);
        }
    }
    adjustHeight(node) {
        var _a, _b;
        if (node == null)
            return;
        node.height = Math.max(((_a = node.left) === null || _a === void 0 ? void 0 : _a.height) || 0, ((_b = node.right) === null || _b === void 0 ? void 0 : _b.height) || 0) + 1;
        this.adjustHeight(node.parent);
    }
    /**
     * ## Find Node with `data` in BST
     * It find the node with the given data and if node doesn't exists it return null
     * @param data target data to search
     * @param end Get first occurrence of node
     * @returns Node in BST | Null if node not found
     */
    findNode(data, end = false, root = this.$ROOT) {
        if (root == null) {
            return null;
        }
        if (end && this.compare(data, root.data) == 0 && root.right) {
            const newRef = this.findNode(data, end, root.right);
            return (newRef === null || newRef === void 0 ? void 0 : newRef.data) == root.data ? newRef : root;
        }
        else if (this.compare(data, root.data) == 0) {
            return root;
        }
        else if (this.compare(data, root.data) == -1) {
            return this.findNode(data, end, root.left);
        }
        else {
            return this.findNode(data, end, root.right);
        }
    }
    /**
     * ## Find Insertion Point for new Node in BST
     * It find the node with the given data and if node doesn't exists it return the position
     * where the node can be inserted.
     * @param data target data to insert
     * @returns Node in BST | Null if tree is empty
     */
    insertionPoint(data, root = this.$ROOT) {
        if (root == null) {
            return null;
        }
        if (this.compare(data, root.data) == 0 && root.right) {
            return this.insertionPoint(data, root.right);
        }
        else if (this.compare(data, root.data) == 0) {
            return root;
        }
        else if (this.compare(data, root.data) == -1) {
            return this.insertionPoint(data, root.left) || root;
        }
        else {
            return this.insertionPoint(data, root.right) || root;
        }
    }
    /**
     * ## Get Next Node in BST
     * @param node The reference node
     * @returns Inorder Successor | null if current node is largest
     */
    next(node) {
        if (node.right != null) {
            return this.leftDescendant(node.right);
        }
        else {
            return this.rightAncestor(node);
        }
    }
    /**
     * ## Get Previous Node in BST
     * @param node The reference node
     * @returns Inorder Predecessor | null if current node is smallest
     */
    prev(node) {
        if (node.left != null) {
            return this.rightDescendant(node.left);
        }
        else {
            return this.leftAncestor(node);
        }
    }
    /**
     * ## Search List of Nodes
     * @param start staring value for search
     * @param end ending value for search
     * @returns A list of nodes within range [`start`, `end`]
     */
    rangeSearch(start, end) {
        const list = [];
        let node = this.findNode(start);
        while (node && this.compare(node.data, end) <= 0) {
            if (this.compare(node.data, start) >= 0) {
                list.push(node);
            }
            node = this.next(node);
        }
        return list;
    }
    insert(data) {
        const node = new Node(data);
        const ref = this.insertionPoint(data);
        if (ref == null) {
            this.$ROOT = node;
            return node;
        }
        if (this.compare(ref.data, data) == 1) {
            ref.left = node;
            node.parent = ref;
        }
        else {
            ref.right = node;
            node.parent = ref;
        }
        this.adjustHeight(node);
        return node;
    }
    deleteElement(target) {
        const left = target.left;
        const right = target.right;
        if (right == null) {
            // promote left
            if (target.parent) {
                if (target.parent.left == target) {
                    target.parent.left = left;
                }
                else {
                    target.parent.right = left;
                }
            }
            else {
                this.$ROOT = left;
            }
            if (left)
                left.parent = target.parent;
            this.adjustHeight(target);
            // dereference target
            target.parent = target.left = target.right = null;
        }
        else {
            const successor = this.next(target);
            if (!successor)
                throw new Error('BST Error: Unexpected Bug!');
            // replace target with it's successor
            target.data = successor.data;
            // remove successor and promote right
            if (successor.parent) {
                if (successor.parent.left == successor) {
                    successor.parent.left = successor.right;
                }
                else {
                    successor.parent.right = successor.right;
                }
            }
            if (successor.right)
                successor.right.parent = successor.parent;
            this.adjustHeight(target);
        }
    }
    delete(data) {
        const ref = this.findNode(data);
        if (ref == null || this.compare(ref.data, data) != 0) {
            // tree empty or element not found
            return;
        }
        this.deleteElement(ref);
    }
    inorder(root, array = []) {
        if (root == null)
            return array;
        this.inorder(root.left, array);
        array.push(root.data);
        this.inorder(root.right, array);
        return array;
    }
    get toArray() {
        return this.inorder(this.$ROOT, []);
    }
}
exports.default = BST;
