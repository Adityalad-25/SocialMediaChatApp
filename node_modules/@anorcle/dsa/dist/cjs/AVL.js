"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("./index.js");
const InvalidOperationError_js_1 = __importDefault(require("./errors/InvalidOperationError.js"));
class AVL extends index_js_1.BST {
    constructor(compare) {
        super(compare);
    }
    rotateRight(node) {
        var _a;
        const parent = node.parent;
        const left = node.left;
        const lRight = (_a = node.left) === null || _a === void 0 ? void 0 : _a.right;
        if (left) {
            left.parent = parent;
            left.right = node;
            node.parent = left;
            node.left = lRight ? lRight : null;
            if (lRight)
                lRight.parent = node;
            if (parent) {
                if (parent.right == node)
                    parent.right = left;
                else
                    parent.left = left;
            }
            this.adjustHeight(node);
            if (parent == null) {
                this.$ROOT = left;
            }
        }
    }
    rotateLeft(node) {
        var _a;
        const parent = node.parent;
        const right = node.right;
        const rLeft = (_a = node.right) === null || _a === void 0 ? void 0 : _a.left;
        if (right) {
            right.parent = parent;
            right.left = node;
            node.parent = right;
            node.right = rLeft ? rLeft : null;
            if (rLeft)
                rLeft.parent = node;
            if (parent) {
                if (parent.right == node)
                    parent.right = right;
                else
                    parent.left = right;
            }
            this.adjustHeight(node);
            if (parent == null) {
                this.$ROOT = right;
            }
        }
    }
    rebalanceRight(node) {
        var _a, _b;
        const left = node.left;
        if (left == null)
            throw new Error('AVL Error: Unexpected Error!');
        const lRHeight = ((_a = left.right) === null || _a === void 0 ? void 0 : _a.height) || 0;
        const lLHeight = ((_b = left.left) === null || _b === void 0 ? void 0 : _b.height) || 0;
        if (lRHeight > lLHeight) {
            this.rotateLeft(left);
        }
        this.rotateRight(node);
    }
    rebalanceLeft(node) {
        var _a, _b;
        const right = node.right;
        if (right == null)
            throw new Error('AVL Error: Unexpected Error!');
        const rLHeight = ((_a = right.left) === null || _a === void 0 ? void 0 : _a.height) || 0;
        const rRHeight = ((_b = right.right) === null || _b === void 0 ? void 0 : _b.height) || 0;
        if (rLHeight > rRHeight) {
            this.rotateRight(right);
        }
        this.rotateLeft(node);
    }
    rebalance(node) {
        var _a, _b;
        const leftHeight = ((_a = node.left) === null || _a === void 0 ? void 0 : _a.height) || 0;
        const rightHeight = ((_b = node.right) === null || _b === void 0 ? void 0 : _b.height) || 0;
        if (leftHeight > rightHeight + 1) {
            this.rebalanceRight(node);
        }
        else if (rightHeight > leftHeight + 1) {
            this.rebalanceLeft(node);
        }
        if (node.parent)
            this.rebalance(node.parent);
    }
    insert(data) {
        if (this.findNode(data)) {
            throw new InvalidOperationError_js_1.default('AVL Error: Duplicate Keys not Allowed!');
        }
        const node = super.insert(data);
        this.rebalance(node);
        return node;
    }
    delete(data) {
        const ref = this.findNode(data);
        if (ref == null || this.compare(ref.data, data) != 0) {
            // tree empty or element not found
            return;
        }
        this.deleteElement(ref);
        const parentOfReplacingElement = this.insertionPoint(data);
        if (parentOfReplacingElement)
            this.rebalance(parentOfReplacingElement);
    }
}
exports.default = AVL;
